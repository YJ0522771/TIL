# 210403

## 백준 알고리즘 문제 풀이

* 1697 : 숨바꼭질 **pass**

  https://www.acmicpc.net/problem/1697

  평범하게 BFS로 K를 찾는 문제.

  

* 17103 : 골드바흐 파티션 **pass**

  https://www.acmicpc.net/problem/17103

  N 범위에서 모든 소수들을 찾은 다음, `N-소수`도 소수인 지를 검사. 

  순서만 다른 경우는 같은 것으로 취급하므로, `N/2`까지만 검사하면 됨.



---



# 210405

## 백준 알고리즘 문제 풀이

* 17071 : 숨바꼭질 5 **pass**

  https://www.acmicpc.net/problem/17071

  목적지인 K가 시간이 지남에 따라 움직인다.

  움직일 수 있는 경로가 x+1, x-1, 2x 이므로, +1과 -1에 의해 일정 장소에 한 번 도달하면 2초마다 그 장소에 돌아오게 된다.

  여기서 많이 헤맸던 부분은 어느 지점에 최초로 도착하는 지점을 짝수 시간과 홀수 시간으로 구분하지 않은 점이다.

  만약 특정 지점에 짝수 시간에 도착했다고 한다면, 그 뒤로 매 짝수 시간마다 해당 지점을 방문할 수 있지만 홀수 시간에 동생이 온다면 이 경로로는 동생을 잡을 수 없다. 하지만 다른 경로를 통해 홀수 시간에도 해당 지점에 방문할 수 있을 수 있으므로, 홀수 시간과 짝수 시간을 따로 저장해줄 필요가 있다.



* 11025 : 요세푸스 문제 3 **pass**

  https://www.acmicpc.net/problem/11025

  검색을 해보니 꽤나 알려진 문제인 듯하다.

  참고 링크 : https://ko.wikipedia.org/wiki/%EC%9A%94%EC%84%B8%ED%91%B8%EC%8A%A4_%EB%AC%B8%EC%A0%9C

  여기서의 인덱스는 0부터 시작한다 사람이 i명이고 k번째마다 퇴장할 때, 마지막 사람의 인덱스를 (i, k)라고 하면,

  `(1, k) = 0` : 사람이 한 명 뿐이므로 첫번째(0) 사람이 마지막 사람이 된다.

  ***<귀납법으로 증명>***

  i = n일 때의 마지막 인덱스를 `(n, k) = x`라고 하면, 

  i = n + 1인 경우는

  `0 1 2 3 ... K-1 K K+1 ... N-1 N` 에서 첫번째 K번째 사람을 빼면,

  `K K+1 K+2 ... N-1 N 0 1 2 ... K-2` 순서의 (n, k)와 동일하게 된다.

  이 때, 기존의 0부터 시작하는 인덱스에서 K를 더한 것과 같으므로 `(x + K) % N` 가 된다. 

  



