# 마이크로 전자계산기

* `PC register` : 다음에 수행할 명령어의 주소가 들어있는 register.
* `Tri-state` 출력
  * 3상태 출력. 1, 0, 고 임피던스 출력.
* Open collector
  * 트랜지스터의 컬렉터 or 드레인이 개방된 구조의 출력 회로.
  * 트랜지스터가 BJT인 경우.
* 캐시 기억장치 (Cache memory)
  * 고속 기억장치.
  * CPU와 주기억장치의 속도 차이를 해결.
* 제어 메모리에서 번지를 결정하는 방법
  * 서브루틴 call, return
  * 명령에서 지정하는 번지로 분기.
  * 상태 비트에 따른 조건부 분기.
  * 매크로 동작 비트로부터 ROM으로 매핑
  * 제어 주소 레지스터 (CAR)를 하나씩 증가.
* `GPIB (general purpose interface bus)`
  * IEEE 488 표준 병렬 인터페이스.
  * 24핀 커넥터를 사용하면 최대 15개의 디바이스를 서로 연결하여 접속할 수 있다.
* `RS-232C` : 직렬통신 인터페이스 표준.
* CMOS
  * 작동속도 : 80~100 ns
  * 높은 집적도.
  * 소비전력이 매우 작음.
  * 잡음 여유도가 큼. 잡음에 대해 안정된 동작 가능.
* 데이지 체인 (Daisy chain)
  * 인터럽트의 **우선순위를 결정**하기 위해 직렬 연결한 하드웨어 회로.
  * 벡터에 의한 인터럽트 처리 방법.
  * 인터럽트 된 모든 장치들은 벡터를 동시에 보낼 수 있음.
* 표준 비동기 직렬 데이터 전송 양식
  * `start bit` : 항상 0.
  * `data bit` : 5~9개 bit.
  * `parity bit` : 짝수 or 홀수.
  * `stop bit` : 항상 1.
* `MAR (memory address register)` : 데이터의 번지를 저장.
* `MBR (memory address register)` : 데이터를 잠시 저장.
* `DRAM (dynamic random access memory)`
  * 휘발성 메모리.
  * 정보를 유지하려면 지속적인 전원 공급 필요.
* `CAM (content addressable memory)`
  * 사용자가 검색어를 제공하면 메모리 전체를 탐색.
* `Dynamic Relocation` : base register를 이용해 가상 메모리 주소를 실제 메모리 주소로 번역.
* cygwin
  * 마이크로소프트 윈도우에서 POSIX 기반 소프트웨어를 구동 및 개발할 수 있는 환경을 제공.
  * GNU GPL로 배포되어 자유롭게 사용.
* perl
  * 주로 유닉스계 os로 사용되고 있는 프로그램 언어. 
* **입출력 프로세서**
  * 입출력 연산을 제어, 관리하는 프로세서.
  * CPU가 입출력 연산에 관여하지 않으므로 처리시간 단축 가능.
  * CPU는 입출력 프로세서에게 입출력 동작을 명령하고, 다른 일을 수행한다.
* 마이크로 cycle time
  * 마이크로 연산을 수행하는데 걸리는 시간.
  * CPU clock 발생 주기와 동기화해주어야함.
* Channel
  * CPU를 거치지 않고 입출력과 주기억장치 간에 데이터 전송을 담당하는 방식.
* Handshaking I/O
  * 비동기 데이터 전송 시에 2~3개의 제어신호를 사용한 송수신 방법.
* Programmed I/O
  * CPU가 직접 입출력 처리.
  * 데이터 전송은 명령이나 입출력 서브루틴에 의해 실행.
* PGA (pin grid array) 구조
  * 대부분의 *마이크로프로세서 CPU 소켓 인터페이스*의 구조.
* **CPU의 하드웨어 요소 기능**
  * 기억 기능.
  * 연산 기능.
  * 제어 기능.
* **pipeline processor**
  * 2개 이상의 명령어를 동시에 수행할 수 있는 프로세서.



#### 마이크로 오퍼레이션 (CPU 동작) 순서

1. `Fetch Cycle` : 주기억장치 → CPU의 명령 레지스터로 가져와 해독.

2. `Indirect Cycle` : Fetch 단계에서 해석한 주소가 간접 주소이면 유효 주소를 계산.

3. `Execute Cycle` : Fetch 단계에서 해석한 명령 실행.

4. `Interrupt Cycle` : 인터럽트 발생 시 복귀 주소 저장. 처리 후 항상 Fetch로 복귀.



#### 주소 지정

> reference : https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=gr25554&logNo=220661797416

##### 직접 주소 지정

##### 간접 주소 지정

* 데이터를 가져오기 위해 메모리를 2번 이상 참조.
* 직접 주소 방식에 비해 느림.



#### UART (universal asynchronous receiver/transmitter), 범용 비동기화 송수신기

* 키보드나 마우스로부터 들어오는 인터럽트 처리.
* 외부 전송을 위해 **패리티 비트** 추가.
* 데이터를 외부로 내보낼 때에는 **시작 비트**와 **정지 비트** 추가.
* 컴퓨터로부터 병렬회로를 통해 범용 바이트들을 외부에 전달하기 위해 하나의 **단일 직렬 비트 스트림**으로 변환.
* 다른 종류의 인터럽트 처리와, 컴퓨터의 동작 속도를 장치의 속도와 동등하게 맞추도록 요구하는 장치 관리.



#### 비동기식 입출력장치

* 송수신 장치가 자신의 타이밍 동작. (독립적)
* 동기용 제어신호를 상대에게 전달.

##### 오픈 루트 방식

##### Handshaking

* 데이터를 상대방 기기에 보냄을 나타내는 제어 신호.
* 데이터를 받음을 알리는 2~3개의 제어 신호.
* 비동기식 제어 방식에서 가장 많이 사용됨.



#### 제어장치 구현 방식

##### 마이크로프로그램 제어방식

* 처리 속도가 비교적 느림.
* CPU의 구조가 변경되어도, 제어장치의 마이크로프로그램만 변경하면 됨.
* 경제적.
* 변경 가능한 제어 기억 소자를 사용하면 제어 변경이 가능.
* 개발기간 단축.
* 에러에 대한 진단 및 수정이 쉬움.

##### 하드와이어드 제어방식

* 디지털 논리회로를 이용.
* CPU 구조가 변경되면 배선을 전부 바꾸어야 함.



#### DMA (direct memory access) 제어기의 구성 요소

* 인터페이스 회로 : CPU - 입출력장치의 통신 담당.
* `주소 레지스터 (address register` : 기억장치와 위치 지정을 위한 번지 기억.
* `워드 카운트 레지스터` : 전송 되어야 할 워드 수 표시.
* `제어 레지스터` : 전송 방식 결정.
* 데이터 버스 버퍼, 주소 버스 버퍼 : 전송에 사용할 데이터나 주소를 임시 저장.
* data counter
* status register



#### 명령어 형식

> reference : https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=davidoff73&logNo=30027805588

##### 0 주소 명령어 (0 address instruction)

* operand부 없이, OP-code부만으로 구성.
* 모든 연산은 stack 메모리의 stack pointer가 가리키는 operand를 이용하여 수행.
* stack machine이라고도 함.
* 수식을 postfix로 변경해야함.
* 원래의 데이터가 남지 않음.

##### 1 주소 명령어 (1 address instruction)

* operand부가 1개로 구성.
* 누산기 (AC, accumulator)를 사용.

##### 2 주소 명령어 (2 address instruction)

* operand부가 2개로 구성된, 가장 일반적으로 사용되는 명령어 형식.
* 여러 개의 범용 레지스터 (GPR)을 가진 컴퓨터에서 사용.
* 장점
  * 3 주소에 비해 명령어 길이가 짦음.
  * 계산 결과가 메모리에 기억되고, CPU에도 남아 있어 계산 결과를 시험하고자 할 때 시간 절약.
* 단점
  * 연산 결과는 op1에 저장하므로, 입력 데이터가 파괴.
  * 전체 프로그램의 길이가 길어짐.

##### 3 주소 명령어 (3 address instruction)

* operand부가 3개로 구성된 명령어 형식.
* 여러 개의 범용 레지스터 (GPR)을 가진 컴퓨터에서 사용.
* 장점
  * 연산 시 입력 데이터를 파괴하지 않음.
  * 프로그램의 전체 길이를 짧게 할 수 있음.
  * 전체 프로그램 실행 시, 주기억장치를 접근하는 횟수가 줄어듦.
* 단점
  * 명령어가 길어짐.
  * 하나의 명령 수행을 위해, 최소 4번 메모리에 접근해야함.
  * 수행시간이 길어짐.



#### 상태 레지스터

* 마이크로프로세서나 처리기 내부에 상태 정보를 간직하도록 설계된 레지스터.

##### 플래그

> reference : https://ko.wikipedia.org/wiki/%EC%83%81%ED%83%9C_%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0

##### 제로 플래그 (Z)

* 연산 결과가 0일 때, 참.

##### 캐리 플래그 (C)

* 부호 없는 숫자의 연산 결과가 범위를 넘었을 때, 참.

##### 보조 캐리 플래그 (A)

* 연산 결과의 하위 니블(4 bit)에서 범위를 넘어섰을 때, 참.
* BCD 연산에 사용.

##### 오버 플로우 플래그 (V / O / W)

* 부호 있는 숫자의 연산 결과가 범위를 넘었을 때, 참.

##### 네거티브 플래그 / 사인 플래그 (N / S)

* 연산 결과가 음수일 때, 참.

##### 인터럽트 플래그 (I / E)

* 이 플래그가 참일 때만 인터럽트 요구를 받아들임.

##### 패리티 플래그 (P)

* 연산 결과 1인 비트 수가 짝수일 때, 참.

