# 전자계산기 구조

* 디지털 IC의 전달 지연시간 순서.
  * (短) `ECL - TTL - CMOS - MOS` (長)
  
* 게이트 당 소모전력이 가장 적은 것 : CMOS

* 명령어 내 bit 할당에 영향을 주는 요소.

  * 주소지정방식, 주소 영역, 연산코드

* **최대 병렬 수행도** (P) : 단위 시간에 처리할 수 있는 최대 비트 수.

  * 비트 슬라이스 : 연산 파이프라인 수 * 각 파이프라인의 단계 수.
  * `P = 비트 슬라이스 길이 * 단어 길이`

* CPI (cycle per instruction) = cycles / instruction

* `MIPS (Millions of instruction per second)`

  = instructions / seconds

  = `frequency (= cycles / seconds) / CPI`
  
* **연관 (associative) 기억장치**

  * 주소 불필요.
  * 고속 메모리.
  * CAM (content addressable memory)
  * 데이터 내용에 의해 접근.
  * mapping table 구성에 주로 사용.
  * 주소에 접근하지 않고 기억된 내용의 일부를 이용.

* **Memory Interliving**

  > reference : https://blog.naver.com/PostView.naver?blogId=roser111&logNo=221695568942&from=search&redirect=Log&widgetTypeCall=true&directAccess=false

  * 메모리를 복수개의 모듈 (bank)로 나누고 각 모듈에 연속적인 주소를 부여하여 동시에 접근 가능하도록 하는 기법.
  * **메모리 접근 시간을 최소화**하기 위함.
  * 메모리에 접근을 각 모듈에 번갈아 가면서 하도록.
  * 각 instruction에 사용하는 데이터 주소에 관계가 있음.
  * 고속의 블록 단위 전송 가능.
  * 캐시 메모리, 고속 DMA 전송 등에서 많이 사용.

* 캐시 메모리 크기

  * (n-way 세트 연관 사상) `n * 2^(word bit) * 2^(set bit)`

* 연산회로에서 필요한 신호

  * 덧셈 신호
  * 보수 신호
  * 끝자리 올림 신호
  
* 짝수 패리티 검출 방식

  * 이진 정보 속에 있는 1의 개수가 패리티 비트를 포함하여 짝수가 되도록.

* 홀수 패리티 검출 방식

  * 이진 정보 속에 있는 1의 개수가 패리티 비트를 포함하여 홀수가 되도록.

* **Data Flow Machine**

  * 명령어 순서에 상관없이 *피연산자의 준비 여부*에 따라 실행되는 방식.



#### 마이크로 명령(instruction) 형식

##### 수평 마이크로 명령

* instruction의 `하나의 bit`가 하나의 동작을 관할.
* micro operation부가 m비트일 때, m개의 동작을 표현.
* address부의 주소를 통해 다음 instruction의 주소를 결정.

##### 수직 마이크로 명령

* 제어 메모리 외부에서 디코딩 회로를 필요로 함.
* 하나의 instruction에 하나의 동작만을 제어.

##### 나노 명령

* 나노 메모리라는 낮은 레벨의 메모리에 저장된 instruction.
* 수직 마이크로 명령을 수행하는 제어기에서 디코더를 ROM(나노 메모리)로 대치하여 두 메모리 레벨로 구성.
* 제어 메모리의 각 word에는 나노 instruction이 저장되어 있는 나노 메모리의 번지들을 저장.



#### 인터럽트 (Interrupt)

##### 인터럽트 기능

* 컴퓨터가 정상적인 작엄을 수행하는 도중에 발생하는 예기치 않은 일들에 대한 서비스를 수행하는 기능.
* 온라인 실시간 처리를 위해 필수적.
* 입출력 인터럽트를 이용하면 중앙처리장치와 주변장치 간의 속도 차이 문제를 해결할 수 있음.

##### 인터럽트 전처리 루틴 (preprocessing routine)

* 인터럽트 불능 instruction을 수행하여, 모든 인터럽트 장치가 인터럽트를 요청하지 못하도록 함.

##### 우선순위 체제

* reference : https://devkim93.tistory.com/entry/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%EC%9A%B4%EC%84%A0%EC%88%9C%EC%9C%84Priority-%EC%B2%B4%EC%A0%9C

* 동시 인터럽트 발생 시, 먼저 처리할 것을 결정.

* 전원 이상 - 기계 착오 - 외부 신호 - 입출력 - 명령어 잘못 - 프로그램 - SVC (supervisor check)

* 하드웨어 우선순위 인터럽트

  * vectored interrupt

* 소프트웨어 우선순위 인터럽트

  * polling

  |             | 하드웨어적 | 소프트웨어적 |
  | :---------: | :--------: | :----------: |
  |  반응 속도  |    고속    |     저속     |
  | 회로 복잡도 |    복잡    |     단순     |
  |   경제성    |  비경제적  |    경제적    |
  |   융통성    |    없음    |     있음     |

##### 인터럽트 발생 시 동작 순서

1. 인터럽트 요청 신호 발생.
2. 현재 수행 중인 프로그램의 상태를 저장.
3. 어느 장치가 인터럽트를 요청했는지 찾음.
4. 인터럽트 취급 루틴을 수행.
5. 보존한 프로그램 상태로 복귀.

##### 인터럽트 요청 시 처리 내용

* 중앙처리장치 : 인터럽트를 요구한 장치를 찾기 위해 입출력 장치를 폴링.
* PSW (program status word)에 현재 상태 보관.
* 인터럽트를 요구한 장치를 위한 인터럽트 서비스 프로그램 실행.
* 인터럽트 서비스 프로그램을 실행하는 중에도 다른 인터럽트를 처리할 수 있다.



#### 해밍 코드 (hamming code)

* reference : https://dreamlog.tistory.com/578
* 예 : 0101의 해밍 코드, 총 7 자리 (p1 p2 d1=0 p3 d2=1 d3=0 d4=1)
  * p1 = (1, 3, 5, 7)에서 첫 번째인 p1를 제외하고 XOR. = 0 xor 1 xor 1 = 0
  * p2 = (2, 3, 6, 7)에서 두 번째인 p2를 제외하고 XOR. = 0 xor 0 xor 1 = 1
  * p3 = (4, 5, 6, 7)에서 네 번째인 p3를 제외하고 XOR. = 1 xor 0 xor 1 = 0
  * 결과 : 0100101
* 데이터로 계산한 패리티 비트 xor 받은 데이터의 패리티 비트 = 오류가 있는 비트 번호
  * 1부터 시작.
  * 맨 뒤의 패리티 비트가 MSB.



#### 다중처리기 상호 연결 방법

* reference : https://smecsm.tistory.com/45

##### 시분할 공유 버스 (time shared single bus)

* 프로세서, 기억장치, 입출력장치 등 사이에 하나의 통신로를 이용하여 전송.
* 시스템이 간단.
* 전송률이 낮음.
* 경제적.
* bus에 이상이 생기면 전체 시스템이 가동 불능.

##### 크로스바 교환 행렬 (crossbar switch matrix)

* 공유 버스 시스템에서 버스의 수를 **기억장치 수만큼** 증가.
* 모든 기억장치에 대한 동시전송이 가능.
* 하드웨어 복잡.
* 전송률이 높음.
* 프로세서가 많은 경우 적합.

##### 하이퍼큐브 상호 연결망

* 많은 수의 처리를 비교적 경제적인 방법으로 연결.
* 다수의 프로세서를 연결할 수 있음.
* 확장성이 좋음.
* 하나의 프로세서에 연결되는 수가 n개일 떄, 프로세서는 총 2^n개가 필요.

##### 다중포트 메모리 (multiport storage)

* 크로스바 교환 행렬 + 시분할 공유 버스.
* 프로세서와 각 메모리 모듈 사이에 **각각의 버스**를 가짐.
* 하나의 프로세서에 하나의 버스가 할당. 
* 경쟁이 적음.
* 비교적 느림.
* 프로세서의 수가 적을 경우 적합.



#### 버스 중재

* reference : https://itstory07.tistory.com/880

* `버스 경합 (bus contention)` : 여러 버스 마스터들이 동시에 버스 사용을 요구.
* `버스 중재 (bus arbitration)` : 버스 경합 발생 시, 우선순위를 정해 버스 마스터들을 하나씩 골라냄.
* `버스 중재기 (bus arbiter)` : 버스를 중재하는 하드웨어 모듈.

##### 제어 신호들의 연결 구조에 따른 분류

* 병렬 중재 방식 (parallel arbitration scheme)
* 직렬 중재 방식 (serial arbitration scheme)

##### 버스 중재기의 위치에 따른 분류

* 중앙 집중식 중재 방식 (centralized arbitration scheme)
  * 시스템 내 중재기가 하나만 존재.
* 분산식 중재 방식 (decentralized arbitration scheme)
  * 여러 개의 버스 중재기 존재. 
  * 일반적으로 버스 마스터마다 중재기 하나.
  * 각 버스 마스터의 중재기에 의해 중재 동작이 이루어짐.

##### 우선순위 결정 방식에 따른 분류

* 고정 우선순위 방식 (fixed priority scheme)

* 가변 우선순위 방식 (dynamic priority scheme)

  * 모든 마스터들이 공정하게 버스 사용.
  * 중재 회로가 복잡.

  1. **회전 우선순위 (rotating priority)**
     * 중재 동작이 끝날 때마다 모든 마스터들의 우선순위가 하나씩 낮아짐. 가장 우선 순위가 낮았던 버스 마스터가 최상이 우선순위를 가지도록.
     * 버스 사용 승인을 받은 버스 마스터는 최하위 우선순위를 가지며, 바로 다음에 위치한 마스터가 최상위 우선순위를 가지도록 하는 방식.
  2. **임의 우선순위**
     * 버스 중재 동작이 끝날 때마다 우선순위를 임의로 결정.
  3. **동등 우선순위**
     * 모든 버스 마스터가 동일한 우선순위.
     * 먼저 요청한 마스터가 먼저 버스 사용 승인을 받음.
     * FIFO.
  4. **최소 최근 사용**
     * 가장 오랫동안 버스를 사용하지 않는 버스 마스터에 최상위 우선순위 할당.



#### 제어장치 구성 요소

* **순서 제어 모듈** : 명령어들의 실행 순서를 결정하는 회로들의 집합.
* **제어 기억장치** : 마이크로 프로그램을 저장하는 내부 기억장치.
* **제어 주소 레지스터 (CAR)** : 다음에 실행할 명령어의 주소를 저장.
* **서브루틴 레지스터 (SBR)** : 서브루틴이 호출되는 경우, 현재의 CAR 내용을 일시적으로 저장.
* **제어 버퍼 레지스터 (CBR)** : 명령어들의 비트들을 일시적으로 저장.
* **Instruction Decoder** : 명령어의 연산 코드를 해독하여 해당 연산을 수행하기 위한 루틴의 시작 주소 결정.



#### 메모리 소자

##### RAM (random access memory)

* 기억 내용을 임의로 읽거나 변경.
* 휘발성.
* `SRAM (static RAM)`
  * 전원 공급을 계속하는 한, 저장된 내용을 기억함. 
  * 플립플롭으로 구성.
* `DRAM (dynamic RAM)`
  * 전원 공급이 계속 되더라도 주기적으로 refresh 필요.
  * 반도체 극 간의 정전 용량에 의한 메모리.

##### ROM (read only memory)

* 읽기 전용.
* 사용자가 기억된 내용을 바꿀 수 없음.
* 비휘발성.
* `Mask ROM`
  * 제조 과정에서 프로그램 기억.
  * 전용 자동제어에 사용.
* `PROM`
  * 사용자가 처음 한 번에 한하여 write 가능.
* `EPROM`
  * 사용자가 여러 번 write 가능.
  * 자외선이나 특정전압 전류로 내용을 지우고 다시 기록할 수 있음.
* `EEPROM (electrical erasable programmable ROM)`
  * 기록 내용을 전기 신호로 삭제 가능.
  * 롬 라이터로 새로운 내용을 쓸 수 있음.



#### parallel process

> reference : https://ypangtrouble.tistory.com/entry/SISD-SIMD-MISD-MIMD

##### SISD

* 제어장치와 프로세서를 하나씩.
* 한 번에 하나의 명령어와 하나의 데이터를 처리.
* 단일 프로세서.
* 명령어가 순서대로 실행.

##### SIMD

* 여러 프로세서로 구성.
* 모든 프로세서는 제어장치로부터 동일한 명령어를 받음. 실행 과정에서 서로 다른 데이터들을 사용.

##### MISD

* 각 프로세서들은 서로 다른 명령어를 실행하지만 처리하는 데이터는 하나의 스트림.

##### MIMD

* 여러 개의 프로세서들이 서로 다른 명령어와 데이터를 처리.
* pipeline process



#### DMA (direct memory access)

* CPU의 도움 없이 메모리와 IO 장치 사이에서 전송을 시행.
* CPU와 DMA 제어기는 메모리와 버스 공유.
* 프로세서에서 사이클을 stealing하여 메모리 버스에 접근.

##### cycle steal

* DMA가 CPU의 사이클을 스틸하여 메모리 버스를 점유.
* CPU의 메모리 접근을 잠시 정지.
* CPU는 스틸된 사이클 동안은 다른 작업을 하지 못함.
* 주기억장치의 사이클 타음을 CPU로부터 DMA가 일시적으로 빼앗는 것.
* CPU는 주기억장치에 접근하지 못함.
* instruction 수행 도중 cycle steal이 발생하면 CPU는 그동안 정지 상태가 됨.
* 사이클 스틸은 상태 보존이 필요 없다.

##### CPU가 DMA에 알려주는 것

* DMA를 시작시키는 명령.
* 입출력 데이터를 저장하고 있는 메모리 주소.
* 데이터 전송 방향 (입력 or 출력)
* 입출력할 장치가 연결된 채널 번호.
* 입출력 하고자 하는 데이터 양.



#### RISC와 CISC

> reference : http://itnovice1.blogspot.com/2019/08/risc-cisc.html

##### RISC (reduced instruction set computer)

* 사용 빈도가 높은 명령어만 사용.
* 명령어 길이가 고정.
* 하드웨어에 의해 직접 명렁 수행.
* 빠름.
* 상대적으로 많은 **범용 레지스터** 사용.
* **하드와이어드** 제어 방식.
* **병렬처리** 가능.
* 복잡한 처리는 소프트웨어에 맡김.
* 데이터 경로 사이클을 단일화.
* ARM

##### CISC (complex instruction set computer)

* 명령어가 **복잡**하여 해석에 오래 걸림.
* 가변 길이.
* 전력 소모가 많고, 느림.
* **메모리**에 접근.
* **마이크로 프로그래밍** 제어 방식.
* 병렬처리 불가.
* 설계는 복잡하나, 프로그래밍이 간단해짐.
* 데이터 경로가 다양.
* x86



