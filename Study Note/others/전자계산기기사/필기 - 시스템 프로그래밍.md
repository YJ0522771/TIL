# 시스템 프로그래밍

* **에이징 (aging) 기법**

  * 우선순위가 낮은 프로세스의 경우, 오래동안 기다릴 수 있음.
  * 기다린 시간에 비례하여 우선 순위를 높여줌.

* **구역성 (locality)**

  * 한 번 호출된 자료나 명령의 기억장소에 대해, 인접한 장소들이 연속되어 사용될 가능성이 높음.
  * 시간 구역성 (temporal locality)
    * 순환 (looping)
    * 부 프로그램 (subroutine)
    * 스택 (stack)
    * 집계 (counting, totaling)에 사용되는 변수.
  * 공간 구역성 (space locality)
    * 배열 순회 (array traversa)
    * 순차적 코드
    * 관련된 변수들을 서로 근처에 선언.

* **세마포어 (semaphore)**

  * 다중 프로세스에서 처리를 조정하거나, 동기화시키는 기술.

* **문맥교환 (context switching)**

  * 하나의 프로세스에서 다른 프로세스로 CPU가 할당되는 과정에서 발생.
  * 현재 프로세스의 상태 정보를 저장하고, 새로운 프로세스의 상태 정보를 설정한 후 CPU를 할당.
  * overhead 시간에 포함.

* **Loader**

  * `allocation` : 메모리 장치 내의 공간 확보.
  * `linking` : 부 프로그램의 시작 주소를 호출한 부분에 등록.
  * `relocation`
  * `loading` : 실행 프로그램을 할당된 메모리 공간에 옮김.

* **Binding**

  * 변하기 쉬운 것을 확고하게 결정짓는 것.
  * global reference들을 절대 번지로 변경. linking과 상대 번지를 변경.

* **Thrashing**

  * 가상기억장치에서 페이지 교환이 자주 일어나는 현상.

* **Parsing**

  * 언어해석기에서 문법에 정의된 내용에 따라 연산자, 피연산자, 키워드 등을 판별하고 구성 요소들의 구조를 알아내는 작업.

* **tracer**

  * 시스템의 동작을 시계열적으로 모니터링하기 위한 도구의 총칭.

* **linker**

  * 컴파일러가 만든 하나 이상의 목적 프로그램을 단일 실행 프로그램으로 병합.

* **교착상태** 발생 조건

  > reference : https://itwiki.kr/w/%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C

  * `상호 배제 (mutual exclusion)` : 한 리소스는 한 번에 한 프로세스만 사용.
  * `점유와 대기 (hold and wait)` : 어떤 프로세스가 하나 이상의 리소스를 점유하고 있으면서, 다른 프로세스가 가지고 있는 리소스를 기다림.
  * `비선점 (no preemption)` : 프로세스가 테스크를 마친 후, 리소스를 자발적으로 반환할 때까지 기다림 (강제로 빼앗지 않음).
  * `환형 대기 (circular wait)` : hold and wait 관계의 프로세스들이 서로 기다림.

* **Working set**

  * 실행 중인 프로세스가 **일정 시간 동안에 참조하는 페이지의 집합**을 의미.
  * 시간이 지남에 따라 자주 참조하는 페이지들의 집합이 변하기 때문에 working set은 시간에 따라 바뀜.
  * 프로그램의 locality를 이용.
  * 프로세스의 기억장치 사용은 안정상태가 됨.
  * working set을 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상을 줄일 수 있다.

* 프로그램 실행 순서

  `source program →  compiler → object program → linkage editor → loader → run `

* **Time Sharing System**
  * 여러 명의 사용자가 사용하는 시스템에서 컴퓨터가 사용자들의 프로그램을 번갈아 가며 처리하여 줌.
  * 각 사용자가 독립된 컴퓨터를 사용하는 느낌을 줌.
* **Swapping**
  * 시분할 시스템 방식에서 주기억장치 내용을 일시적으로 보조기억장치 데이터나 프로그램과 교체.



#### 시스템 소프트웨어

* HW와 application software를 연결하는 역할.
* 시스템의 제어 및 관리를 수행.
* 프로그램을 주기억장치에 적재, 인터럽트 관리, 장치관리 등.
* 사용자 소프트웨어와 구별.



#### 운영체제

* 기능
  * 자원 보호.
  * 자원 스케줄링.
  * 기억장치 관리 기능.



#### 언어 번역 프로그램

* 종류
  * **컴파일러**
  * **인터프리터**
    * 대화식 언어 번역기.
    * 목적 프로그램을 생산하지 않음.
  * **어셈블러**
    * 기호 언어인 어셈블리어 번역기.
    * 목적 프로그램 생산.



#### Formal grammar

##### 4가지 형태

1. 정규 문법 (regular grammar)
2. 문맥 자유형 문법 (context-free grammar)
3. 문맥 의존형 문법 (context sensitive grammar)
4. 비제한 문법 (no restriction grammar)



#### 어셈블리어

* 의사 명령 (pseudo instruction)
  * 어셈블러 명령.
  * 원시 프로그램을 어셈블할 때, 어셈블러가 하여야할 동작을 지시하는 명령.
  * 예 : START, END, USING, DROP, EQU 등
* 실행 명령
  * 어셈블리어 명령.
  * 데이터를 처리하는 명령.
  * 예 : A, AH, AR, S, SR, L, LA, ST, C, BNE 등

* `TEST` 
  * 논리적인 비교 결과가 양수인지 음수인지를 검사. 
  * 상태 레지스트의 상태 비트 설정.
* `LEA (load effective address)`
  * source operand의 주소값을 destination operand로 복사.
* `NEG`
  * 피연산자의 2의 보수 계산.
  * 결과를 피연산자에 저장.
* `CWD (convert word to dword)`
  * word의 크기를 dword로 확장.

* `BALR`
  * BALR R1, R2
  * register R1에 다음 명령어의 주소를 적재. register R2가 가지고 있는 번지로 분기.
  * R2가 0이면 다음 명령 수행.
* `EQU`
  * 값에 상징된 이름을 부여.
  * 어떤 기호적 이름에 상수 값을 할당.
* `ASSUME`
  * 세그먼트 레지스터에 각 세그먼트의 시작 번지를 할당.
  * 현재의 세그먼트가 어느 것인가를 지적하게 함.
* `ORG`
  * 원시 프로그램을 목적 프로그램으로 번역할 때, 현재의 operand에 있는 값을 다음 명령어의 번지로 할당.



#### 어셈블러

##### 이중 패스 (two pass)

* 사용 이유
  * 한 개의 패스만을 사용하는 경우, 기호를 모두 정의한 뒤에 해당 기호를 사용하여야 함.
  * 기호를 정의하기 전에 사용할 수 있어 프로그램 작성이 용이. (**전향참조, forward reference**)
  * 사용의 편의상, 정의하기 전에 사용한 주소 상수를 처리하기 위함.



#### 매크로 프로세서

##### 기본 수행 작업

* 매크로 정의 저장
* 매크로 정의 인식
* 매크로 호출 인식 (매크로 명령의 호출을 인식)
* 매크로 호출 확장



#### 작업 제어 언어 (job-control language)

* 프로그램의 순차적 실행을 지시.
* 논리적 장치와 물리적 장치를 연결.
* 프로그램 및 시스템 운영에 관한 지시를 운영체제에 전달.
* 기종마다 다름.
* 사용자와 시스템의 다리 역할.
* accounting에 필요한 정보 제공.



#### Paging

##### 페이지 크기

* 페이지의 크기가 *작을수록* 페이지 테이블의 크기가 커짐. 참조되는 정보와 무관한 정보들이 많이 적재되어 내부 단편화가 증가.
* 페이지의 크기가 *클수록* 참조되는 정보와 무관한 정보들이 많이 적재.
* 작은 크기의 페이지가 보다 적절한 작업세트를 유지할 수 있음.
